静态变量类型	       定义位置	             作用范围	                    使用方法	                  赋值方式
全局静态变量	    文件内（函数、类外）	      定义所在的文件	                 文件内直接使用	         定义时初始化一次
类的静态成员变量	类内声明，类外定义	          类共享，所有对象共享同一份	     类名::变量名 或对象访问	 类外定义时初始化
局部静态变量	         函数内	              仅函数内部可见，生命周期贯穿程序	 函数内直接使用	         第一次调用时初始化一次
静态变量的生命周期与程序生命周期一致

c++中struct和class的功能几乎是一致的，仅仅只是访问修饰符的区别，但struct在实际开发过程中更多是用于实现贫血模型，而不会定义复杂行为。
struct一般是定义在头文件中。

数组：
在 C++ 中，是否使用 delete 或 delete[] 完全取决于是否使用了 new 或 new[]，而不是取决于变量本身是不是一个数组。
在 C++ 中，动态数组的元素不能是引用，只能是对象和指针
指针数组的定义：数组和数组元素都是指针类型 int **a = new int *[]{new int(1), new int(2)};
数组可以分为：静态数组（指针数组和非指针数组）和动态数组（指针数组和非指针数组）
动态数组一定是指针类型

& 的含义取决于它的上下文
用作声明时，& 表示引用类型，意味着这个变量是另一个变量的别名。
用作运算时，& 表示取地址运算符，即获取变量的内存地址（返回指针类型）。

指针：
指针既可以在栈上分配，也可以在堆上分配,int *a = &b; 和 int *a = new int(10); 都是指针类型

new:
在 C++ 中，new 是一个关键字，用于动态分配内存。在运行时，它从堆（heap）中分配一块指定大小的内存，并返回指向该内存的指针

构造函数初始化列表
构造函数初始化列表是一个在构造函数函数体执行之前初始化成员变量的语法。它的基本形式如下：
ClassName() : member1(value1), member2(value2) {
    // 构造函数的函数体
}
member1(value1) 表示将成员变量 member1 初始化为 value1。
初始化列表的执行早于构造函数主体的执行。

035原则
035原则的本质目的是为了管理资源
0 原则：非指针类型的成员变量，使用默认的特殊成员函数（析构函数、拷贝构造函数、拷贝赋值运算符等）即可。
3 原则：需要深拷贝的场景，避免共享资源导致的资源重复释放或修改冲突的问题。
5 原则：转让所有权，避免深拷贝的性能开销。
使用5原则的时候，就应该包含所有的特殊函数，比如：析构函数、拷贝构造函数、拷贝赋值运算符等、移动构造函数、移动赋值运算符

多态
虚表（VTable）本质上就是一个表格，里面存储的是虚函数的具体实现函数的地址。可以将它理解为一个用于动态函数绑定的映射表，目的是让程序在运行时通过查表找到虚函数的实现。
多重继承-菱形继承
同一个基类被多个派生类继承，然后这些派生类又被一个子类继承 的情况
      A
     / \
    B   C
     \ /
      D
1.	基类实例重复：
•	D 中会间接包含两份 A 的实例（分别从 B 和 C 继承），导致数据冗余和资源浪费。
2.	调用的二义性：
•	如果 A 中有方法或成员，D 无法确定是从 B 路径的 A，还是从 C 路径的 A 调用，产生二义性。
这里要用虚拟继承解决, D 只包含一个共享的 A 实例，无论通过多少条路径继承。
D
├── B
├── C
└── A (共享实例)

内存布局
数据段中的数据只包括静态变量、常量、全局变量，成员变量是在类实例中，类实例可能在堆,也可能在栈

异常处理
异常类继承关系：
std::exception
   ├── std::logic_error
   │       ├── std::domain_error
   │       ├── std::invalid_argument
   │       ├── std::length_error
   │       └── std::out_of_range
   └── std::runtime_error
           ├── std::range_error
           ├── std::overflow_error
           ├── std::underflow_error
           └── 用户自定义的其他派生类
exception是异常基类，如果抛出的话，构造函数没有任何参数，自定义异常需要继承exception
	1.	如果异常是因为开发者代码逻辑导致的（参数不合法、数据状态错误），选择 std::logic_error。
	•	逻辑错误意味着程序需要在开发阶段修复，运行时不应发生。
	2.	如果异常是因为外部条件（例如文件、网络、用户输入等），选择 std::runtime_error。
	•	运行时错误意味着需要在运行时捕获并处理。
c++任何类型的异常都不需要强制捕获，他们仅仅只是语义上的差异。
class MyException1 : public std::exception {
    string msg;

public:
    MyException1(const string &msg) : msg(msg) {
    }

    MyException1(const string &msg, const std::exception &e) {
        this->msg = format("{}:{}", msg, e.what());
    }

    /**
     * 继承std::exception需要重写what函数
     */
    const char *what() const noexcept override {
        return msg.c_str();
    }
};
c++除了异常标准库外，还可以抛出任何类型，比如string、int，捕获时可以使用catch(...)通配符来捕获所有异常(通常是兜底逻辑),由于 catch(...) 不接受参数，你无法通过它直接访问异常的内容。
noexcept 的主要作用之一就是通知编译器目标函数不会抛出异常，从而允许编译器进行性能优化。不过，这只是 noexcept 的一个主要功能，它还有其他方面的作用，例如提升代码的安全性和健壮性。
try {
    throw 42;                // 抛出整数
    throw std::string("Error occurred"); // 抛出字符串
} catch (const int& e) {
    std::cout << "Caught integer: " << e << std::endl;
} catch (const std::string& e) {
    std::cout << "Caught string: " << e << std::endl;
}
c++异常catch块中声明引用是为了防止对象切割。


什么是对象切片（Object Slicing）？
对象切片是指将派生类对象赋值给基类对象时，基类对象只保留了基类部分的数据，而丢失了派生类的特性（如派生类的成员变量和虚函数行为）。
Base baseObj = derivedObj; 会调用 Base 的拷贝构造函数。
	•	Base 的拷贝构造函数只会复制 Base 部分的数据，而派生类 Derived 的部分（包括 extra 和重写的 print() 方法）被切割。
	•	导致 baseObj.print() 调用的是基类的 print()，而不是派生类的重写版本。
c++中值拷贝会引起对象切片问题，而指针和引用变量则不会。
// 指针变量
User1 *u1 = new User2;
// 引用变量
{
    User2 u2;
    User1 &u1 = u2;
}

未定义行为（UB）
由于违反语法规则而无法预测程序的具体行为，比如访问空指针、悬垂指针、数组越界、未初始化访问，可能的结果是导致程序崩溃，需要使用内存检测工具进行分析检测。
在 C++ 中，变量需要显式初始化，否则未初始化的变量可能会导致 未定义行为
默认未初始化的变量（无论是基本数据类型还是类类型）都可能包含未定义的值（garbage value）

内存错误排查
在完成代码编写后，使用 AddressSanitizer（ASan）等工具对代码进行内存错误检测(空指针、悬垂指针、数组越界)是非常好的习惯
AddressSanitizer（Asan）：支持GCC/CLANG
g++ -std=c++20 -fsanitize=address -g -o rlt *.cpp

左值、右值问题
这个问题是由于试图将一个右值（如临时对象或返回值）绑定到一个 非 const 的左值引用 导致的。右值不能直接绑定到非 const 引用，这是 C++ 的一个规则
什么是左值和右值？

1.	左值 (Lvalue)
•	概念: 左值是指可以被命名、可以取地址的东西。
通俗来说，左值是程序中 “可以放在赋值操作左边” 的变量或对象。
•	特点:
•	左值有持久的内存地址，生命周期通常比当前表达式长。
•	左值可以被修改（前提是不加 const）。
•	例子:
int x = 10;   // x 是左值，可以命名，可以取地址
x = 20;       // x 可以放在赋值操作左边

2.	右值 (Rvalue)
•	概念: 右值是指没有名字、无法取地址的临时值。
通俗来说，右值是程序中 “只能放在赋值操作右边” 的值，如常量、表达式的结果。
•	特点:
•	右值通常是临时的，生命周期只持续到表达式结束。
•	右值不能直接被修改。
•	例子:
int x = 10 + 20;  // 10 和 20 是右值，表达式 (10 + 20) 的结果 30 也是右值
int y = 42;       // 42 是右值

左值和右值的绑定规则
规则 1: 非 const 左值引用 (T&)

	•	只能绑定到左值，不能绑定到右值。
	•	这样做是为了避免修改临时对象（右值）的行为，因为右值是短暂的，修改它没有意义。

示例:
int x = 10;
int& ref1 = x;       // OK，x 是左值
int& ref2 = 10;      // 错误！10 是右值，不能绑定到非 const 引用

规则 2: const 左值引用 (const T&)

	•	可以绑定到 左值 和 右值。
	•	绑定到右值时，右值的生命周期会被扩展到引用的生命周期，这样可以安全地使用右值。

示例:
const int& ref1 = x;  // OK，x 是左值
const int& ref2 = 10; // OK，右值 10 可以绑定到 const 引用
std::cout << ref2;    // 可以安全使用右值

规则 3: 右值引用 (T&&)（C++11 引入）

	•	专门用于绑定右值，不能绑定左值。
	•	右值引用的主要作用是支持 移动语义 和 完美转发，以优化性能。

示例:
int&& ref1 = 10;      // OK，右值 10 可以绑定到右值引用
int&& ref2 = x;       // 错误！x 是左值，不能绑定到右值引用

总结
左值是变量，右值是表达式或者返回值，非const左值引用只能绑定左值，const左值引用可以绑定左值和右值，右值引用只能绑定右值。

ADL(参数查找)
ADL（参数相关查找）是 C++ 中的一种机制，根据函数参数的类型，自动在参数所属命名空间中查找匹配的函数，无需显式指定命名空间。
ADL并不属于 动态绑定 的范畴，而是 编译期的静态查找机制。
作用和价值
	1.	自动根据参数类型绑定命名空间函数，减少显式命名空间调用，降低命名冲突。
	2.	提升泛型代码的灵活性和可扩展性。
注意：
对于成员函数，ADL 不会直接查找到它们，因为成员函数必须通过类的实例来调用。ADL 主要针对的是非成员函数，通常是全局函数或友元函数(friend)。

类型转换
static_cast（静态转换）的特性
1.	编译期的类型转换：
    •	static_cast 是一种 编译期的检查动作，编译器会根据类型的兼容性规则进行转换，但不会在运行时进行检查。
    •	不仅仅针对原始类型，它可以用来转换类之间的指针或引用，以及各种自定义的类型。
2.	支持任意类型之间的显式转换：
    •	只要编译器认为类型转换在语法上是合理的，static_cast 就可以执行。
    •	但如果实际类型在运行时不匹配，可能导致 未定义行为。
3.	可能的未定义行为：
    •	static_cast 不会检查对象的实际类型，例如在将基类指针强制转换为派生类指针时，如果基类指针实际上不是指向派生类的对象，访问派生类的成员将导致未定义行为。

dynamic_cast（动态转换） 的特性
1.	运行时类型检查：
    •	dynamic_cast 是一种 运行时检查的类型转换，需要依赖 RTTI（运行时类型信息）。
    •	编译时会生成类型信息，运行时会检查对象的实际类型是否与目标类型匹配。
2.	限制为多态类：
    •	只有多态类（即至少有一个虚函数的类）才能使用 dynamic_cast，因为它依赖虚表（vtable）来进行类型检查。
3.	安全性：
    •	如果转换失败，指针转换会返回 nullptr，引用转换会抛出 std::bad_cast 异常。
    •	不会出现未定义行为。


reinterpret_cast 在 C++ 中是最不受限制的类型转换，但它不能直接用于转换值类型（如 int 转 float）。
原因在于 reinterpret_cast 的设计目的和适用范围是针对指针、引用和某些特定情况的重解释，而不包括值类型的转换。

uintptr_t 和指针类型的区别：
都用于表示内存地址，但它们的目的和用法有显著区别。
指针类型

	•	定义： 指针类型（如 int*、char*）用于存储指向特定类型对象的内存地址。
	•	本质： 指针不仅仅是地址，它还携带了类型信息，可以通过解引用操作访问指向的对象。
	•	大小： 指针的大小与平台相关（32 位系统通常为 4 字节，64 位系统为 8 字节），但它的类型决定了解引用操作如何解释所指向的数据。

uintptr_t

	•	定义： uintptr_t 是 C/C++ 标准库提供的一个无符号整数类型，专门用于以整数形式存储指针值。
	•	本质： 它是一个与指针大小一致的无符号整数类型，用于纯粹表示内存地址，而没有任何类型信息。
	•	大小： uintptr_t 的大小由平台决定，足够存储任何指针值，与 void* 的大小一致。

C++宏
宏 (#define) 来自 C 语言的设计（C语言诞生于 1972 年），最初是为了解决常量和代码片段复用的问题，作为一种简单的文本替换机制。
宏的特点是无需类型定义，实现简单且高效，但也因为缺乏类型安全性和调试能力，容易引发问题。

宏可以分为：常量宏、宏函数、使用符号“#”开头的条件编译，#include不是宏

常量宏：
#define PI 3.14159
现代 C++ 中，更推荐使用 const 或 constexpr 代替常量宏，因为它们提供了更强的类型安全性和调试能力