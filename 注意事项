静态变量类型	       定义位置	             作用范围	                    使用方法	                  赋值方式
全局静态变量	    文件内（函数、类外）	      定义所在的文件	                 文件内直接使用	         定义时初始化一次
类的静态成员变量	类内声明，类外定义	          类共享，所有对象共享同一份	     类名::变量名 或对象访问	 类外定义时初始化
局部静态变量	         函数内	              仅函数内部可见，生命周期贯穿程序	 函数内直接使用	         第一次调用时初始化一次
静态变量的生命周期与程序生命周期一致

c++中struct和class的功能几乎是一致的，仅仅只是访问修饰符的区别，但struct在实际开发过程中更多是用于实现贫血模型，而不会定义复杂行为。
struct一般是定义在头文件中。

数组：
在 C++ 中，是否使用 delete 或 delete[] 完全取决于是否使用了 new 或 new[]，而不是取决于变量本身是不是一个数组。
在 C++ 中，动态数组的元素不能是引用，只能是对象和指针
指针数组的定义：数组和数组元素都是指针类型 int **a = new int *[]{new int(1), new int(2)};
数组可以分为：静态数组（指针数组和非指针数组）和动态数组（指针数组和非指针数组）
动态数组一定是指针类型

& 的含义取决于它的上下文
用作声明时，& 表示引用类型，意味着这个变量是另一个变量的别名。
用作运算时，& 表示取地址运算符，即获取变量的内存地址（返回指针类型）。

指针：
指针既可以在栈上分配，也可以在堆上分配,int *a = &b; 和 int *a = new int(10); 都是指针类型

new:
在 C++ 中，new 是一个关键字，用于动态分配内存。在运行时，它从堆（heap）中分配一块指定大小的内存，并返回指向该内存的指针

构造函数初始化列表
构造函数初始化列表是一个在构造函数函数体执行之前初始化成员变量的语法。它的基本形式如下：
ClassName() : member1(value1), member2(value2) {
    // 构造函数的函数体
}
member1(value1) 表示将成员变量 member1 初始化为 value1。
初始化列表的执行早于构造函数主体的执行。

035原则
035原则的本质目的是为了管理资源
0 原则：非指针类型的成员变量，使用默认的特殊成员函数（析构函数、拷贝构造函数、拷贝赋值运算符等）即可。
3 原则：需要深拷贝的场景，避免共享资源导致的资源重复释放或修改冲突的问题。
5 原则：转让所有权，避免深拷贝的性能开销。
使用5原则的时候，就应该包含所有的特殊函数，比如：析构函数、拷贝构造函数、拷贝赋值运算符等、移动构造函数、移动赋值运算符

多态
虚表（VTable）本质上就是一个表格，里面存储的是虚函数的具体实现函数的地址。可以将它理解为一个用于动态函数绑定的映射表，目的是让程序在运行时通过查表找到虚函数的实现。
多重继承-菱形继承
同一个基类被多个派生类继承，然后这些派生类又被一个子类继承 的情况
      A
     / \
    B   C
     \ /
      D
1.	基类实例重复：
•	D 中会间接包含两份 A 的实例（分别从 B 和 C 继承），导致数据冗余和资源浪费。
2.	调用的二义性：
•	如果 A 中有方法或成员，D 无法确定是从 B 路径的 A，还是从 C 路径的 A 调用，产生二义性。
这里要用虚拟继承解决, D 只包含一个共享的 A 实例，无论通过多少条路径继承。
D
├── B
├── C
└── A (共享实例)

内存布局
数据段中的数据只包括静态变量、常量、全局变量，成员变量是在类实例中，类实例可能在堆,也可能在栈

异常处理
异常类继承关系：
std::exception
   ├── std::logic_error
   │       ├── std::domain_error
   │       ├── std::invalid_argument
   │       ├── std::length_error
   │       └── std::out_of_range
   └── std::runtime_error
           ├── std::range_error
           ├── std::overflow_error
           ├── std::underflow_error
           └── 用户自定义的其他派生类
exception是异常基类，如果抛出的话，构造函数没有任何参数，自定义异常需要继承exception
	1.	如果异常是因为开发者代码逻辑导致的（参数不合法、数据状态错误），选择 std::logic_error。
	•	逻辑错误意味着程序需要在开发阶段修复，运行时不应发生。
	2.	如果异常是因为外部条件（例如文件、网络、用户输入等），选择 std::runtime_error。
	•	运行时错误意味着需要在运行时捕获并处理。
c++任何类型的异常都不需要强制捕获，他们仅仅只是语义上的差异。
class MyException : public std::exception {
    string msg;

public:
    MyException(string str) : msg(str) {
    }

    MyException(string msg, std::exception &e) {
        this->msg = msg + ":" + string(e.what());
    }

    const char *what() const noexcept override {
        return msg.c_str();
    }
};
c++除了异常标准库外，还可以抛出任何类型，比如string、int，捕获时可以使用catch(...)通配符来捕获所有异常(通常是兜底逻辑),由于 catch(...) 不接受参数，你无法通过它直接访问异常的内容。
noexcept 的主要作用之一就是通知编译器目标函数不会抛出异常，从而允许编译器进行性能优化。不过，这只是 noexcept 的一个主要功能，它还有其他方面的作用，例如提升代码的安全性和健壮性。
try {
    throw 42;                // 抛出整数
    throw std::string("Error occurred"); // 抛出字符串
} catch (int e) {
    std::cout << "Caught integer: " << e << std::endl;
} catch (std::string& e) {
    std::cout << "Caught string: " << e << std::endl;
}
c++异常catch块中声明引用是为了防止对象切割。


什么是对象切割（Object Slicing）？
对象切割是指将派生类对象赋值给基类对象时，基类对象只保留了基类部分的数据，而丢失了派生类的特性（如派生类的成员变量和虚函数行为）。
Base baseObj = derivedObj; 会调用 Base 的拷贝构造函数。
	•	Base 的拷贝构造函数只会复制 Base 部分的数据，而派生类 Derived 的部分（包括 extra 和重写的 print() 方法）被切割。
	•	导致 baseObj.print() 调用的是基类的 print()，而不是派生类的重写版本。
而指针和引用变量则不会。

内存错误排查
在完成代码编写后，使用 AddressSanitizer（ASan）等工具对代码进行内存错误检测(空指针、悬垂指针、数组越界)是非常好的习惯
AddressSanitizer（Asan）：支持GCC/CLANG
g++ -std=c++20 -fsanitize=address -g -o rlt *.cpp

左值、右值问题
这个问题是由于试图将一个右值（如临时对象或返回值）绑定到一个 非 const 的左值引用 导致的。右值不能直接绑定到非 const 引用，这是 C++ 的一个规则


