静态变量类型	       定义位置	             作用范围	                    使用方法	                  赋值方式
全局静态变量	    文件内（函数、类外）	      定义所在的文件	                 文件内直接使用	         定义时初始化一次
类的静态成员变量	类内声明，类外定义	          类共享，所有对象共享同一份	     类名::变量名 或对象访问	 类外定义时初始化
局部静态变量	         函数内	              仅函数内部可见，生命周期贯穿程序	 函数内直接使用	         第一次调用时初始化一次
静态变量的生命周期与程序生命周期一致

c++中struct和class的功能几乎是一致的，仅仅只是访问修饰符的区别，但struct在实际开发过程中更多是用于实现贫血模型，而不会定义复杂行为。
struct一般是定义在头文件中。

数组：
在 C++ 中，是否使用 delete 或 delete[] 完全取决于是否使用了 new 或 new[]，而不是取决于变量本身是不是一个数组。
在 C++ 中，动态数组的元素不能是引用，只能是对象和指针
指针数组的定义：数组和数组元素都是指针类型 int **a = new int *[]{new int(1), new int(2)};
数组可以分为：静态数组（指针数组和非指针数组）和动态数组（指针数组和非指针数组）
动态数组一定是指针类型

& 的含义取决于它的上下文
用作声明时，& 表示引用类型，意味着这个变量是另一个变量的别名。
用作运算时，& 表示取地址运算符，即获取变量的内存地址（返回指针类型）。

指针：
指针既可以在栈上分配，也可以在堆上分配,int *a = &b; 和 int *a = new int(10); 都是指针类型

new:
在 C++ 中，new 是一个关键字，用于动态分配内存。在运行时，它从堆（heap）中分配一块指定大小的内存，并返回指向该内存的指针

构造函数初始化列表
构造函数初始化列表是一个在构造函数函数体执行之前初始化成员变量的语法。它的基本形式如下：
ClassName() : member1(value1), member2(value2) {
    // 构造函数的函数体
}
member1(value1) 表示将成员变量 member1 初始化为 value1。
初始化列表的执行早于构造函数主体的执行。

035原则
035原则的本质目的是为了管理资源
0 原则：非指针类型的成员变量，使用默认的特殊成员函数（析构函数、拷贝构造函数、拷贝赋值运算符等）即可。
3 原则：需要深拷贝的场景，避免共享资源导致的资源重复释放或修改冲突的问题。
5 原则：转让所有权，避免深拷贝的性能开销。
使用5原则的时候，就应该包含所有的特殊函数，比如：析构函数、拷贝构造函数、拷贝赋值运算符等、移动构造函数、移动赋值运算符

多态
虚表（VTable）本质上就是一个表格，里面存储的是虚函数的具体实现函数的地址。可以将它理解为一个用于动态函数绑定的映射表，目的是让程序在运行时通过查表找到虚函数的实现。
多重继承-菱形继承
同一个基类被多个派生类继承，然后这些派生类又被一个子类继承 的情况
      A
     / \
    B   C
     \ /
      D
1.	基类实例重复：
•	D 中会间接包含两份 A 的实例（分别从 B 和 C 继承），导致数据冗余和资源浪费。
2.	调用的二义性：
•	如果 A 中有方法或成员，D 无法确定是从 B 路径的 A，还是从 C 路径的 A 调用，产生二义性。
这里要用虚拟继承解决, D 只包含一个共享的 A 实例，无论通过多少条路径继承。
D
├── B
├── C
└── A (共享实例)

内存布局
数据段中的数据只包括静态变量、常量、全局变量，成员变量是在类实例中，类实例可能在堆,也可能在栈